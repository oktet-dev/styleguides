\input texinfo @c -*-texinfo-*-

@c
@c C Source Code Style Guide
@c
@c Copyright (C) 1999 Terkom, St.-Petersburg, Russia
@c Copyright (C) 2003 OKTET Ltd., St.-Petersburg, Russia
@c Copyright (C) 2004 OKTET Labs, St.-Petersburg, Russia
@c
@c Author: Andrew Rybchenko <Andrew.Rybchenko@oktetlabs.ru>
@c Author: Dmitry V. Semyonov <Dmitry.Semyonov@oktet.ru>
@c Author: Victor V. Vengerov <Victor.Vengerov@oktetlabs.ru>
@c

@c Standard title (it is duplicated in @settitle)
@set TITLE  C Source Code Style Guide

@c Identifier of this document
@set ID     OKTL-0000034

@c Type 'Draft', 'Approved', 'Issued', or 'Obsolete' here
@c It's duplicated in 'Document status' section
@set STATUS Draft

@c Use A-Z letters for different versions of document drafts.
@c Use 1-N numbers for different versions of document issues.
@set REV    E
@set DATE   2 Aug 2004

@c Comma-separated list of years to be used in copyright notices
@set YEARS 1999, 2003, 2004


@c -*%header%
@setfilename OKTL-0000034.txt
@settitle    C Source Code Style Guide
@ifinfo
@exampleindent 0
@end ifinfo
@iftex
@exampleindent 0
@end iftex
@afourpaper
@setcontentsaftertitlepage
@setchapternewpage off
@c %header%*-




@copying
Copyright @copyright{} 1999 Terkom, St.-Petersburg, Russia

Copyright @copyright{} 2003 OKTET Ltd., St.-Petersburg, Russia

Copyright @copyright{} 2004 OKTET Labs, St.-Petersburg, Russia

This document is the property of OKTET Labs. Nevertheless, there are no
special restrictions regarding confidentiality which limit the audience
or distribution of this memo.
@end copying


@c -*%titlepage%

@titlepage
@title    @value{TITLE}
@subtitle Internal Standard @value{ID}
@c Note the use of three `l's in the word `filll'; this is correct.
@vskip 0pt plus 1filll
@insertcopying
@end titlepage


@iftex
@oddheading  @value{TITLE} @| @| @value{ID}
@evenheading @value{ID}    @| @| @value{TITLE}
@oddfooting  @thispage     @| @| 
@evenfooting               @| @| @thispage
@end iftex

@c %titlepage%*-


@page


@unnumbered Abstract

This document describes the general formatting rules of C programming
language constructs, naming conventions and coding style.


@unnumbered Copyright Notice

Copyright @copyright{} 1999 Terkom,  St.-Petersburg, Russia

Copyright @copyright{} 2003 OKTET Ltd., St.-Petersburg, Russia

Copyright @copyright{} 2004 OKTET Labs, St.-Petersburg, Russia


@unnumbered Audience

This document is intended for OKTET Labs C programmers, reviewers,
testers and other persons involved in software development process.

It is assumed that a reader is familiar with the C programming language.


@unnumbered Document status

@c @value{STATUS}
Draft


@unnumbered Contact Information

@display
Unit 3H, Universitetsky pr., 18/2, Petrodvorets, St.-Petersburg, Russia
Phone: +7(812) 428-6709
Fax: +7(812) 428-7715
@end display

For more information, call the above office or visit our web site at
@uref{http://www.oktetlabs.ru}.

Please, send your comments and notes about found errors, typos, and
inconsistencies to @email{support@@oktetlabs.ru}.


@page


@unnumbered Revision History

@example
Date     Rev  Author              Changes
----------------------------------------------------------------------------
1999     A    Victor V. Vengerov  Initially written

Feb, 23  B    Dmitry V. Semyonov  Typos fixed.
2003                              Reformatted according to OKTET Generic
                                  Document Template.
                                  Added doxygen related information.

Mar, 4   C    Dmitry V. Semyonov  Fixes after review
2003

Mar, 18  D    Elena A. Vengerova  OKTET Labs identifier is assigned
2004

Aug, 2   E    Andrew Rybchenko    Contact information updated. Typos fixed.
2004                              Victor V. Vengerov notes applied.
----------------------------------------------------------------------------
@end example


@unnumbered Issues

@itemize @bullet
@item
The document should be updated after more experience of Doxygen usage is
achieved.
@end itemize


@page


@chapter Abbreviations

@table @samp
@item ANSI
American National Standards Institute
@item CR
Carriage Return
@item CVS
Concurrent Version System
@item LF
Line Feed
@item WRS
Wind River Systems
@end table


@chapter Terminology

@table @samp
@item Subsystem
Functionally closed, alienable, possibly reusable, software component
with well defined external interfaces. It may be library, tool, device
driver, part of OS, etc.
@item Doxygen
A documentation system for C++, C, and several other programming languages.
See 'Doxygen manual' for more information.
@end table


@chapter References

This work is inspired by many existing coding standards and our own experience
in C software development and understanding of foreign source code. Most
notable documents which have been used to create this standard are

@itemize @bullet
@item
L.W.Cannon, R.A. Elliot et.al. "Recommended C Style and Coding Standards"
(based on Indian Hill C Style and Coding Standard).
@item
R. Stallman "GNU Coding Standards" 
(March 1998, (C) Free Software Foundation)
@item
J.K. Ousterhout
Tcl/Tk Engineering Manual
@item
WRS Coding Conventions
@item
Doxygen manual
@end itemize


@chapter Introduction

The main purpose of this standard is to define a framework which can
help us to develop source code in a clear and uniform manner. Another
goal is to define a base for automatic generation of convenient on-line
and printable documentation directly from sources.

This document defines the ``low-level'' C coding conventions, structure
of C source files, naming conventions, commenting style which must be applied
to developing of C source code. We have tried not only give a pandect of
rules, but also give rationale and reasons for some of them.

Doxygen-specific guidelines concerning resulting documentation
formatting and common issues will be described a separate document.


@section Contributors

@itemize @bullet
@item
Victor V. Vengerov @email{Victor.Vengerov@@oktetlabs.ru}
@item
Elena A. Vengerova @email{Elena.Vengerova@@oktetlabs.ru}
@item
Konstantin Abramenko @email{Konstantin.Abramenko@@oktetlabs.ru}
@end itemize


@chapter General


@section Style remarks

C language has a pretty simple syntax, nevertheless it is possible to write
extremely complicated code. The following example, taken from 
@cite{``Obfuscated C Contest''} archive, is a correct C program; you can
try to compile and execute it:

@verbatim
main() { printf(&unix["\021%six\012\0"],(unix)["have"]+"fun"-0x60); }
@end verbatim

How much time you need to understand how it works? :-)

It is good for fun, but absolutely not applicable for development of a
big software project, which must be supported by many people during few
years. Your code may be read by many people, and it is very important to
make your code understandable for them. Every time have in mind that you
are writing code not for compiler, but for human. Limit your fantasy to
make your code clear.


@section Text width

Any line of C source code couldn't be longer than 80 characters.

Remember that during debugging and further development of your program
you often insert additional @code{if} statements moving your original
code more and more to the right. Try to keep your original code in 60-70
character limit.

If C source code is generated by other programs, tools, scripts, and
produced code is not intended to be human-readable, it is not required
to follow 80 character limitation.


@section File length

Source code file length is not limited explicitly. More important aspect
in division of source code to many files is to reflect logical structure
of specific program or project. Nevertheless, each file must have a
reasonable size. It is not possible to give hard limitations of source
length; it seems that 800-4000 lines of code is a good source size and
up to 6000-8000 lines is acceptable.

If C source code is generated by other programs, tools, scripts, the
file  length is not limited.


@section Special Characters

Lines in source file are separated by character @samp{LF} (hex code
0x0a). It is not allowed to use @acronym{MS-DOS} standard @samp{CR-LF}
sequence for line delimiting.

It is permitted (but not required) to insert @samp{FF} character (Form
Feed, hex code 0x0c) to separate logically independent parts of source
code  (functions or function groups, variable declaration groups, etc).
This character shall not be used inside function body.

It is prohibited to use control characters immediately in string
constants or comments. For strings you may use escape sequences instead.

Do not forget to setup your text editor program so that it will insert
appropriate number of spaces instead of @samp{TAB} (hex code 0x09)
character on @key{TAB} key pressing.


@section Trigraphs

Do not ever use the ``trigraphs'' feature of @acronym{ANSI} C. (If you
don't know what does it mean - don't worry, it will be better if you
never know about it).


@section Indentation

Indentation is used to show structure of algorithms or data types.
Usually, each statement in complex statement is started at the same
column, and each nested statement is indented relative to its
``parent''. Precise rules specific to each C language construct provided
below.

Indentation level is 4 character. It means that every nested block shifted
to 4 character right relatively to the position of its ``parent block''.

If a nested block is a complex statement surrounded with curly brackets
(braces), these brackets must be placed at the position of ``parent'' block.

The following example demonstrates this:

@verbatim
    while (p != NULL)
    {
        for (i = 0; i < p->tabsize; i++)
        {
            if (p->tab[i] == x)
                return i;
        }
        return 0;
    }
@end verbatim


@section Vertical spacing

@itemize @bullet
@item
Use blank lines to make code more readable. Group logically related sections
of code together.
@item
It is not recommended to put more than one declaration to the line. (It is
allowed to put two-three declarations of tightly-related variables in one
line to emphasize their relationship).
@item
It is @emph{highly not recommended} to put more than one statement on a
line. (It is allowed to put two-three very simple and tightly-related actions
(something like i++; j++;) on the one line.) Exception: @code{for} statement,
when initial, condition and loop statement could be written on a single line;
see templates below.
@item
Curvy braces (@{ and @}) always (except @code{do...while} loop)
get their own line.
@end itemize


@section Special compiler features

Usually, each compiler provides some non-standard facilities, which are not
supported by other compilers. Examples are assembler insertions, function or
parameters attributes which make possible, for example, associate parameters
with a specific processor registers, nested functions, and so on. You must
understand that usage of such features will complicate porting of your code
very much. It is @emph{highly} not recommended to use such features. In
some situations, usage of such features may be acceptable. In any case, it may
be used only in a limited number of modules, and preferable under
conditional preprocessor directives. Compiler-depended features like
@code{inline} function attribute must be used via appropriate preprocessor
definition.


@chapter Naming conventions


Choosing names is one of the most important aspects of programming. Good
names clarify the function of a program and reduce the need for other
documentation. Poor names result in ambiguity, confusion and errors.

The ideal name is one that instantly conveys as much information as possible
about the purpose of an entity (variable, function, field, etc.) it refers to.
Try to choose names in such way that they could not be misinterpreted or
confused by other programmers.

Here is the check list for names:
@itemize @bullet
@item
Check that the name is consistent. Use the same name to refer to the same 
entity everywhere. For example, if you have passed a pointer to some structure 
descriptor in each function in a module, give the same name to the 
correspondent parameter.
@item
Check if the name may be misunderstood out of context. For example, if function
which performs swapping of odd and even bytes is called @code{swap_buffer()},
this name may be understand incorrectly in other context: somebody may think
that you have meant swapping buffer to the disk.
@item
Check if the name may be confused with some other name. For example, if two
variables with names @code{str} and @code{string} in the same procedure both
refer to strings, it is hard to anyone to remember which is which.
@item
Check if the name is so generic that it doesn't convey any information.
@end itemize

Words and abbreviations from non-English languages cannot be used to
form identifiers. Use underscore character @samp{_} to separate the
words. Do not fear to use long identifiers. In any case, an identifier
@emph{must not contain} pronouns, interjections, private names,
nicknames, or place names.

Variable, type, field names must be in lower case only. Use upper case for
preprocessor names and enum constants. Do not mix upper and lower case 
letters in the same name.

If you have chosen some abbreviation, document it and use the same 
abbreviation everywhere in the program.

You must have in mind possible name conflicts when you assign a name to an
entity. A conflict may occur if two global variables or functions are defined 
in two places, or if some header files contain declaration of types,
preprocessor variables, structs, etc. with the same name, and these headers may
be included both. The only way how to avoid such conflicts is to give names
in a consistent manner.

You must add module-@  or subsystem-specific prefixes to globally visible
names. It is recommended to have prefix not less than 3 character long;
2-character prefix is allowed for some significant wide-used subsystems.
A prefix must be the same for all global names in module or subsystem. All
globally-visible variables and functions must be prefixed. Also, it is highly
recommended to give prefixes to all declarations, type names, preprocessor
variables, struct names in header files which may be included from external
components. It is not required (but allowed), to prefix local names (names
in the header files which may be included only in particular subsystem and not
exported to the outer world, static variables and functions). Do not prefix
field names in structures and unions.

It is recommended for uniformity to use @samp{object + action +
object/property} style while giving a name to a function. Besides, this
style is convenient when module prefix is used in place of the first
object. For example, @code{fat_get_cluster(), pkt_send_raw()}.

The only exception for the above rules is if you are implementing
something using externally given (standardized) specification.
Therefore, it is not required to rename @code{printf} to
@code{libc_printf} if you are implementing @acronym{ANSI} C library!


@chapter Conventional comments


Comments are special remarks intended first of all for human reader, who
needs to understand your work. Comments are very important parts of your
code, it is a way to make your program simple and well-readable. Lack of
comments or inaccurate comments may make life for reader (and may be for you
too!) very complex.

This chapter provides general rules for comment writing.


@section Comment designators

Comments are started with the sequence @code{/*}. Comments are finished with
the sequence @code{*/}. It is prohibited to use C++ line comment designator
@code{//} even if your compiler supports it. Nested comments are not allowed.

Don't use @code{/*} and @code{*/} sequences for temporary removing pieces
of your code. Use preprocessor directives instead.


@section Language

All comments in your program shall be written in English, because English is
the only language that nearly all programmers in all countries can read.

If it is declared in technical requirement document, that comments must be
written in any other language UTF-8 character set should be used.

Multilingual comments within sources are @emph{highly} not recommended.
It is proposed to use separate translation files for such cases.


@section Formatting conventions

The text of your comment must follow some simple usual conventions. Statement
must be started from capital letter (except case when the first word is a name
of variable, type etc. You must avoid this, but if you need, write name
exactly as it is used). Put one space character between words in sentences.
Couple punctuation mark to the left word and insert a space character after
punctuation mark. Put an empty line between paragraphs. You must put space
character after @code{/*} and before @code{*/}.

Two comment styles may be used: one-line comments and multiline comments.
One line comment looks like this:

@verbatim
/* This is example of one-line comment */
@end verbatim

Multiline comments look like this:

@verbatim
/*
 * This is example of multiline comment. Such comment layout must be used
 * if your text couldn't be fitted in one 80-character line. Please, note
 * that each line is started with the asterisk character.
 */
@end verbatim

Code comments must be indented as appropriate piece of code.

Some specific comment formatting considerations provided in appropriate
chapters of this document.


@section Comments style

The purpose of comments is to save time and reduce errors. Comments are
typically used for two purposes. First, people will read the comments
to find out how to use your code. For example, they will read procedure
headers to learn how to call the procedures. Ideally, people should have to
learn as little as possible about your code in order to use it correctly.
Second, people will read the comments to find out how your code works
internally, so they can fix bugs or add new features. More documentation
isn't necessarily better: reading pages of comments may be not easier than
understanding uncommented code.

It is most important to comment things which affect many different
pieces of program. Thus it is required that every procedure interface,
every structure declaration, and every global variable must be commented
clearly. If you haven't commented one of these things it will be
necessary to look at all the uses of the thing to understand how it's
supposed to work.

On the other hand, things with only local impact may not need much
documentation. If the overall purpose of the function has been explained,
and if there isn't much code in the procedure, and if variables have
meaningful names, it is not required to give any comments at all. For long
functions, comment local variables and logical blocks of function. Also,
comment a tricky situations, non-obvious code which depends on information
to someone reading it for the first time.

Document each thing in exactly one place. If something is documented in
several places, it will be hard to keep the documentation up to date as the
system changes. Try to document each major design decision in exactly one
place.

Don't just repeat what is already obvious from the code, like this:
@verbatim
    i += 1;   /* Increment i */
@end verbatim

Documentation should provide higher-level information about the overall
function of the code, helping readers to understand what a complex
collection of statements really means.

It is extremely important to write comments as you write the code. Don't
delay documentation writing until you finish to implement and change
your code. You will never write good comments in such case, because you will
never stop coding: there is always more code you have to write. If you
accumulate more undocumented code, it will be harder to you to find energy
and time to comment it. So, you just write more undocumented code. Finally,
you may forget some important things which must be documented.

If you write comments as you go, it won't add much to your coding time and
you won't have to worry about doing it later. Therefore, it is required to
write comments as you write the code.


@chapter File layout


This chapter describes general rules about C source and headers file layout.


@section Order of file sections

Every file containing C source code must be started from standard file
header. After the header the following sections should be included in the 
specified recommended order:

@itemize @bullet
@item
General file documentation. It is a C comment consisting of a complete
description of the overall module purpose and function.

@item
@dfn{Includes}. The include section (if exists) consist of one or more C
preprocessor @code{#include} directives. This section groups all header
files included in the module in one place. In most cases, system include
files, such as @file{stdio.h}, should be included first. Subsystem
interface include files (see below) usually must be included before
subsystem headers. Header files that declare functions or external
variables should be included in the file that defines the function or
variable.

@item
@dfn{Defines}. The defines section (if it exists) consists of one or more C
preprocessor @code{#define} directives. This section (if it exists) groups
all definitions made in module in one place.

@item
@dfn{Types}. This section (if it exists) contains all struct, typedef, enum
definitions and groups it together.

@item
@dfn{Forwards}. The forward declarations section (if it exists) consists
of one or more @acronym{ANSI} C function prototypes. This section
groups all such declarations together.

@item
@dfn{Globals}. This section (if it exists) consists of all
external-visible variables definitions and groups it together.

@item
@dfn{Locals}. This section consists of all variables visible only inside this
module (static variables) and groups it together.

@item
@dfn{Functions}. The functions section (if it exists) consists of one or more C
function definitions. This section groups all such declarations together.
In this section similar functions (functions on a similar level of
abstraction) should be placed together.
@end itemize

If you see that it is better to repeat some of these sections two or
more times to group similar things together, you may do it, saving
provided order in each such group. However, all functions should be
implemented after all preceding definitions anyway. Nevertheless,
remember that it means that your software is likely to have a poor
design. It is recommended to split source or header file to many smaller
ones in this case.


@section Human-written file headers

Each @samp{.c} or @samp{.h} files written by human, must have a formal
header. This header starts at the first line of source file. A header
has the following format:

@verbatim
/** @file
 * @brief <subsystem description>
 *
 * <module description>
 * 
 * <copyright notice>
 *
 * @author <author name> <<author e-mail>>
 *
 * <license term notice>
 * 
 * $Id: $
 */
@end verbatim

@dfn{Subsystem description} is a short (one-line preferred) description of
subsystem to which this file belongs. This line must be same for all files
of this subsystem.

@dfn{Module description} is a short description of a source file. It
should be started with upper-case letter, and finished with dot.

@dfn{Copyright notice} must provide information about copyright holder of
this work. This line must consist of word @samp{Copyright}, copyright sign
@samp{(C)}, organization name which holds copyright, and its location
(city and country). It is allowed multiple @samp{Copyright} sections if
your source contains fragments copyrighted by different organizations.

@dfn{@@author} section of the header must provide information about
principal developer of this module. The section consists of the author's
name (in English transcription) and e-mail address which may be used
later to contact the author regarding to these sources. It is allowed to
have multiple @samp{@@author} sections if principal developer has been
changed; put a name of the last principal developer first. OKTET Labs
employees shall use <Name.Surname@@oktetlabs.ru> form of e-mail address.

Optional part @samp{license term notice} may be added to provide
information about licensing terms for this source file, about distribution
permissions or restrictions, or to refer to a particular license text.

The last line of the header is a substitution for source code system
(e.g. @acronym{CVS}) information. @samp{$@asis{}Id: $} sequence will be
substituted with actual module identification string while a file is
committed into @acronym{CVS} repository.

Note that doxygen-style comment and @-tags are used here.

@verbatim
/** @file
 * @brief ncr875 controller device driver
 *
 * Chip-specific primitive implementation.
 *
 * Copyright (C) 1999 OKTET Labs, St.-Petersburg, Russia
 *
 * @author Victor V. Vengerov <Victor.Vengerov@oktetlabs.ru>
 * @author Dmitry V. Semyonov <Dmitry.Semyonov@oktet.ru>
 *
 * $Id: $
 */
@end verbatim


@section Generated file headers

Some of source files fed to compiler may be generated by other programs
or scripts. Such programs or scripts must put special header at the beginning 
of such files:

@verbatim
/*
 * This file is automatically generated by program <program>.
 * DO NOT EDIT IT!!!
 *
 * File generated at <date> <time>
 */
@end verbatim


@section Header (@samp{.h}) files

Header files are started with the same header as @samp{.c} files. Header
files must include C variable and function declarations, common type
definitions, preprocessor definitions, definitions of inline functions which
may be used in more than one C module. Each module which requires
definitions from headers must include appropriate header using preprocessor
directive @code{#include}. If some header file uses definitions or
declarations from another header file, it is recommended to include that
header file to the first one. (Usually, header file contains some interface
definition, and it is poor if user of this interface must know about
internal things needed for this interface declaration.)

There are two kinds of header files: which define interface to subsystem
and which define inter-module interfaces inside specific subsystem.
Try not to mix these two kinds of header files. Do not include internal
definitions and declarations to the interface headers.

Header file must be started with the same header as C source code file.
The body of header file must be organized in the following way:

@verbatim
#ifndef __<subsystem_prefix>_<filename>_H__
#define __<subsystem_prefix>_<filename>_H__
#ifdef __cplusplus
extern "C" {
#endif

...

#ifdef __cplusplus
}
#endif
#endif /* __<subsystem_prefix>_<filename>_H__ */
@end verbatim

In this fragment @samp{<subsystem_prefix>} must be substituted with
capitalized subsystem abbreviation, @samp{<filename>} must be
substituted with capitalized form of header file name. If the filename
already contains the subsystem prefix there is no need to add another
one.

Conditionals @code{#ifdef __cplusplus} used to make possible usage of
appropriate header in C++ program. These preprocessor conditionals may be
omitted in internal headers, but are mandatory for interface headers.


@chapter Function Definition Formatting


@section Function header

It is required to put formal function header before each function definition.
Function header have the following format:

@verbatim
/**
 * <function description>
 *
 * @param <param1>      <param1 description> [ (OUT) | (IN/OUT) ]
 * @param <param2>      <param2 description> [ (OUT) | (IN/OUT) ]
 * ...
 *
 * @return <return value description>
 *
 * @retval <retval1>    <retval1 specification>
 * @retval <retval2>    <retval2 specification>
 * ...
 *
 * @se <side effects description>
 *
 * @sa <closely related functions and documentation references>
 *
 * @alg <algorithm description>
 *
 * @bug <bug description>
 *
 * @todo <todo description>
 */
@end verbatim

Not all parts must be presented in each function header.

The only always required part is @samp{<function description>}. It
should be started with upper-case letter, and finished with dot. It is
recommended to use common style of the form 'Copy bytes' (which is
opposite to 'Copies bytes') for documentation similarity.

At the same time it is @emph{mandatory} to describe all function
parameters and returned value(s). If a function does not return a value,
@samp{@@return} part may be omitted, or <return value specification> may
be @samp{N/A} (not applicable). If a value directly returned by a function
lies within a limited set of constants, then each constant should be
described using @samp{@@retval} tag.

If a parameter is used to deliver values out from a function, it is
allowed to add @samp{(IN/OUT)} or @samp{(OUT)} (depending on whether
the parameter is used or not as input at the same time accordingly) hint
to the end of parameter description. @samp{(IN)} is assumed by default,
and should not be used.

@samp{@@se} (side effects) part must be presented only when a function
has non-obvious side effects. For example, if this function essentially
modifies common data structures, and it is not clear from its name, or a
function prints something to standard output, changes state of some
hardware, and so on.

Use optional @samp{@@sa} (see also) part to give references to closely
related functions and documentation blocks.

Optional @samp{@@bug} and @samp{@@todo} sections may be used to identify
found bugs or things that need to be done accordingly.

@samp{@@alg} (algorithm) part must be provided only when it is not enough
to define @emph{what} function does; it is necessary to explain @emph{how}
this achieved.


@subsection Indentation inside function header

The function description as well as any of the sections beginning tags
must be started from the 3rd column position (beginning with 0) just
after the @samp{' * '} sequence of characters.

Use exactly one @samp{SPACE} character between any of section beginning
tags and start of section body, if the body begins on the same line with
a tag.

<paramX description>, <retvalX specification>, as well as any line
(except first) of multiline section must be indented by multiples of 8
spaces. This simplifies text formatting with TAB key. The whole indented
description must form a single column. In other words, it is not allowed
to have a line indented by 8 characters, and other one indented by 16.


@section Function Formatting

All functions must be defined in @acronym{ANSI} C format. Function definition
must look like this:

@verbatim
/** 
 * Create object instance of class 'objclass' which designates to be
 * referred as a null object of this class. If 'name' is given
 * (not equal to NULL), register object instance with given name.
 *
 * @param  objclass     Class object identifier.
 * @param  name         Null object name, or NULL.
 *
 * @return
 *      Object identifier for null object of class 'objclass', or
 *      OBJID_NULL, if error occurred.
 */
static objid
object_create_null(objid objclass, char *name)
{
    objid obj;
    
    obj = class_instantiate(objclass);
    if (obj == OBJID_NULL)
    {
        return OBJID_NULL;
    }
    if (name != NULL)
    {
        int rc;
        
        rc = object_register_with_name(obj, name);
        if (rc != OBJ_SUCCESSFUL)
        {
            object_delete_instance(obj);
            return OBJID_NULL;
        }
    }
    return obj;
}
@end verbatim

Please, pay your attention to the following topics:

@itemize @bullet
@item
Open and close curly brackets must be placed at the column zero.
@item
Function name is started at column zero.
@end itemize

Such formatting will simplify use of some tools. For example, @command{grep}
command can be used to find location of a specific function definition:

@example
@cartouche
$ grep ^object_create_null *
@end cartouche
@end example

If argument list can not fit in one line, this line can be split in the
following way:

@verbatim
static objid
datafile_encode(int in_file_desc, int out_file_desc, char *encoding_key,
                int encoding_key_len, int control)
{
    ...
}
@end verbatim


@section Considerations

It is @emph{highly not recommended} to pass or return structures to or
from functions. Pass pointers instead and make a copy inside the function if
it is really necessary.

It is required to define a function with @code{static} specifier if the
function must be visible only inside a current module (file).

Function return type must be declared. Do not default it to
@code{int}; if a function does not return a value then it must be
given return type @code{void}.


@section Function size

It is not possible to give hard limits for function code size. In any case,
remember that it is better if function is pretty simple, pretty short and
pretty clear. If it is possible, try to limit function size by 25-27 lines
of code - such functions usually may fit on one terminal screen; this
simplifies understanding what function does. If it is not possible, size up to
70-140 lines is good, and up to 400-500 is acceptable. If your function is
overgrown, try to redesign it to isolate logically separable parts in
different functions.


@section Parameters and local variables conventions

Function parameters may be divided into three categories.

@itemize @bullet
@item
@dfn{In} parameters only pass information into the function (either 
directly or by pointing to information that the function read).
@item
@dfn{Out} parameters point to things in the caller's memory that the procedure
modifies.
@item
@dfn{In-out} parameters do both.
@end itemize

Parameters should normally appear in the order @{in, in-out, out@}.

Parameters which have source/destination semantics must always appear in
the order @{destination, source@}.

If there is a group of functions, all of which operate on structures of a
particular type (hash table, device descriptor structure, etc), parameter
which points to this structure should be the first argument of each
function. All such parameters must have the same name.

Do not use @code{auto} memory class specifier with local variables. If you
think that some (3-4 maximum) variables are used in a critical part of code
or are frequently used, you may give @code{register} memory class specifier.

Avoid local declarations that override declarations at higher levels. In
particular, local variables must not be redeclared in nested blocks.


@section Local variables naming conventions

It is recommended to give short but clear names to local variables. Here are
some recommended names for local variables. All these names may be used with
possible digit suffixes.

Names @code{i}, @code{j}, @code{k} must be used as names for loop variables.

Names @code{n}, @code{m} must be used as a names for variables which contain
a number of some entities. Variable name @code{l} may be used for length of
something.

Names @code{s} or @code{str} (only one of them in one function!) may be used
as a pointer to character strings.

Names @code{s} or @code{sock} may be used for a socket file descriptors.

Name @code{fd} may be used to refer to a file descriptor variable.

Name @code{f} may be used for a file descriptor or @code{FILE} variable
associated with file (@emph{not} socket or device).

Name @code{fn} may be used for a string constanting the file name.

Names @code{p}, @code{q} must be used as a pointer to some data element
(structures, elements of array, etc). It is acceptable to use @code{p} and
@code{q} identifiers as pointers to character arrays too.

Names @code{t}, @code{tmp} must be used as temporary variables.

Name @code{src} may be used as a pointer to source of string, buffer,
structure, etc. Name @code{dst} may be used as a pointer to destination.

Names @code{in} and @code{out} must be used for pointers or indexes in
input and output data.

Name @code{c} may be used as a temporary variable for character.

Name @code{que} may be associated with some kind of queue.

Names @code{x}, @code{y}, and @code{z} may be associated with coordinates.

Names @code{w} and @code{h} may be associated with width and height of
something.

Name @code{a} may be used for a some kind of addresses. Names @code{pa} and
@code{va} may be used for physical and virtual addresses accordingly.

Name @code{conn} may be used for a file descriptor or other entity
representing connection.

@emph{Example:}

@verbatim
    int i;
    
    ...
    
    p = &queue_pool[0];
    n = sizeof(queue_pool);
    if (n > max_queue_size)
    {
        n = max_queue_size;
    }
    for (i = 0; i < n; i++)
    {
        p->data = NULL;
        p->id = i;
        p->next = p + 1;
        p++
    }
@end verbatim

It is not allowed to have more than three variables with the same name and
different suffixes.

Comments for local variables are necessary only when it is really necessary.
You must comment non-obvious variables in long functions only. It is not
necessary to comment variables which are used in clear way, for example
loop counters, etc.


@chapter Types definitions formatting


@section @code{struct} declaration


@subsection @code{struct} comments

You must insert comment immediately before structure declaration which
describes purpose of this structure, usage conventions and give other
necessary information.

You must give a detailed comment for each field of declared structure.

Usually understanding of data structures used in program is a key to
understanding of a whole system. Please, write accurate and detailed 
comments for structure declarations.

Comments for structure fields must be placed in the same line where a
field is declared. All comments must be indented to the same level. It
is allowed (but not recommended) to shift comments to the right from
common level if some field names are longer than others and such shifts
allow to avoid  splitting comments to several lines. If comment is
split a new line must be indented to the level of first comment
letter following the @code{/*} sequence. See examples below.


@subsection @code{struct} formatting

The @code{struct} declaration must look like this:

@verbatim
/** Node of the double-linked list */
struct list_node {
    struct list_node  *next;    /**< Next node in double-linked list */
    struct list_node  *prev;    /**< Previous node in double-linked list */
    int                size;    /**< Information field size */
    char               node[0]; /**< Information field designator */
};
@end verbatim

If @code{struct} declaration is used in a variable declaration or
@code{typedef} declaration, @code{typedef} or variable specifiers must
be placed before @code{struct} keyword on the same line, and identifier
must be placed after close bracket on the same line:

@verbatim
/** NCR875 SCSI host adapter user-settable hardware parameters */
typedef struct ncr875_hw_regs {
    int diffScsi;  /**< Differential SCSI bus enable */
    int TolerANT;  /**< TolerANT enable */
    int slowCable; /**< Slow cable mode (Extra clock cycle of Data Setup) */
    int burstLen;  /**< Maximum number of transfers performed per PCI bus
                        ownership, legal values is 2,4,8,16,32,64,128 */
} ncr875_hw_regs;
@end verbatim

In @code{typedef} declaration, it is recommended to give the same name to
@code{struct} name in @code{struct} namespace and to @code{typedef} name.

All field names must be started at the same position. The choice of the 
position is based on the maximum length of field type specifiers used in 
structure. Note that reference specifiers @samp{*} must be coupled to field
name, but placed at left from common field indentation level.

It is @emph{highly not recommended} to join struct and variable
declaration. Declare types and variables separately.
 
In some cases nested @code{struct/union} declarations are acceptable,
but it is not recommended.


@subsection Bit fields

You may use bit fields to save memory if you know how much bits is
sufficient to store some specific value. But in any case you should not make 
any assumptions about order in which these bit fields are allocated, because 
it may be compiler-specific. Therefore, it is prohibited to declare, for 
example, hardware register layout as a structure with bit fields, or represent
structure of binary file in such way, or define structure of data which will
be sent over network.


@section @code{union} declaration

All conventions provided for struct formatting are applied to @code{union}
declarations.


@section @code{enum} declaration


@subsection @code{enum} formatting conventions

The @code{enum} declaration must look like this:

@verbatim
/** LED status constants */
enum led_status {
    LED_STATUS_OFF   = 0, /**< LED is off */
    LED_STATUS_ON    = 1, /**< LED is on */
    LED_STATUS_FAIL  = 2, /**< LED is unfunctional */
    LED_STATUS_MAINT = 4  /**< LED is now in maintenance mode; operations are
                               limited */
};
@end verbatim

The same rules for typedef/variable definitions as for structures are applied.

Each @code{enum} component must occupy a separate line.


@subsection @code{enum} elements conventions

@code{enum} members must be prefixed with some abbreviation common for
all members.

It is necessary to give a value for each member, if this value is specified
externally (in manual, data sheet, technical specification, etc). Otherwise
it is recommended not to assign values, or assign a value to the first element
only.


@section Type qualifiers

Don't forget to give type qualifiers (@code{const} and @code{volatile}) when
it is necessary, especially @code{volatile} specifier.

Absence of @code{volatile} specifier in place where it is required is a
serious subtle error. Save your time and think every time when
@code{volatile} specifier may be significant. Do not give @code{volatile}
specifier to types, fields, variables which do not require it, because it
may lead to misunderstanding and make your code worse.

It's @emph{highly} recommended to give @code{const} specifier
when it is applicable, because it may make compiler output better and
help you to avoid some errors.


@chapter Variable declaration formatting

Each variable declaration must be started on a separate line.
Global-space variables definitions must be started at column 0.
Local variables must be started at block indent level, same
as for the statements in this block.
@samp{*} specifiers must be placed near variable name.

Variable declarations may be divided into blocks separated by empty line
and block comment. The common formatting rules are applied inside one block.

@verbatim
/* Phase correction algorithm variables */
static fixed16  phase_error; /**< Currently estimated phase error */
static int      phcorr_num;  /**< Number of processed samples */
static fixed16 *sample;      /**< Next sample pointer */
@end verbatim

Variable names in a block start at the same column. Variable comments
start at the same column. If comment couldn't be fitted in one line, it may
be split. Continuation line should begin at the same column where first 
letter of comments after @code{/*} was placed.

@verbatim
static uint32     input_bit_number;   /**< Number of bits received from
                                           external interface */
@end verbatim

If variable block has only one declaration inside, variable comment may be
omitted.


@chapter Literals and constants


Try not to use numeric constant values in code (except simple cases, like
constants 0, 1, -1 and in some rare situations when direct constant usage
may be more clear than identifier usage - for example bit masks like 0xff).

When multiline string constant is used, it is recommended to insert
@samp{\n} character explicitly and close quote at each line.

@emph{Examples:}

@verbatim
/* Right: */
void
usage_information_print(void)
{
    printf("check -- check C source code to the C Source Code Style "
           "conformance\n"
           "Usage:\n"
           "    check <filename>\n");
}

/* Wrong: */
void
usage_information_print(void)
{
    printf("
check -- check C source code to the C Source Code Style conformance
Usage:
    check <filename>\n");
}
@end verbatim

If constant length suffix is used, the capital suffix letter must be used
(use @code{0L}, not @code{0l}). Similarly, for floating point constants,
use capital exponent letter @samp{E} (use @code{1.25E+35}, not
@code{1.25e+35}).

In hexadecimal constants, lower-case letters must be used (use
@code{0xdeadbeef}, not @code{0xDEADBEEF}).


@chapter C Expressions


Unary operators @samp{&}, @samp{*}, @samp{+}, @samp{-}, @samp{~},
@samp{!}, @samp{++}, @samp{--} must be coupled with operands to which such
operators are applied.

Binary operators
@samp{*}, @samp{/}, @samp{%}, @samp{+},
@samp{-}, @samp{>>}, @samp{<<}, @samp{<}, @samp{>},
@samp{<=}, @samp{>=}, @samp{==}, @samp{!=}, @samp{&}, @samp{^}, @samp{|},
@samp{&&}, @samp{||},
@samp{=}, @samp{*=}, @samp{/=}, @samp{%=}, @samp{+=}, @samp{-=}, @samp{<<=},
@samp{>>=}, @samp{&=}, @samp{^=}, @samp{|=}
must be separated by one space at left and right.

Operators @samp{.} and @samp{->} must be coupled with both operands.

Operator @samp{,} (comma) must be coupled to its left operand and separated
by one space character from the right operand.

Operator @samp{[]} must be coupled to the left and inner operands.

Syntactic components of conditional operator @samp{a ? b : c}
must be separated by one space character. It is recommended to enclose
conditional operator into the parenthesis.

Grouping parenthesis must be coupled with the contents inside brackets.

In function call no delimiters must be added between function name
or function expression and left round bracket. Also, no delimiters
must be inserted between open round bracket and first operand and between
close round bracket and between last operand.

@samp{sizeof} operator must use syntax similar to function call.

Round brackets of type cast operator must be coupled with type specifier and
with operand.

It is allowed to use embedded assignment statement if it make code simpler
and better readable. Don't use embedded assignment in artificial places. For
example,

@verbatim
    x = x1 + w;
    pos = ofs + x;
@end verbatim

should not be replaced by

@verbatim
    pos = ofs + (x = x1 + w);
@end verbatim

@emph{More examples:}

@verbatim
    p = p->next;  /* Correct */
    n = - n;      /* Incorrect */
    ++ b;         /* Incorrect */
    b++;          /* Correct */
    printf("Internal error: %d\\n", (class << 8) | errno);
    scsi_freq = (freq_multiplier ? freq * 2 : freq);
    list = hash_tab[hash_func(key) % hash_mod];
    memcpy(dest, src, n);
@end verbatim

It is recommended to insert additional unnecessary parenthesis to
expression to make it more readable. It is recommended to assume only that
unary operators have higher priority than binary and that multiplication
operators has higher priority that addition.

It is allowed to insert additional spaces between binary operators, if it is
improve readability. For example, if you have a group of statements which
fill fields of structure, code with aligned assignment operators seems
better. Sometimes, additional spaces may help to show structure of complex
expressions.

Do not test non-boolean expression as you test a boolean. For example, where
@code{x} is integer, use @code{if (x == 0)} instead @code{if (!x)}.

When you split expression into multiple lines, break line after operator.
Line up continuation lines with the part of the preceding line they
continue.
 

@chapter C Statements Formatting


@section @code{if} statement

@code{if} statement must look like this:

@verbatim
    if (p != NULL)
    {
        if (p->flag & FEL_INACTIVE)
            continue;
        else
            p = p->next;
    }
@end verbatim

It is recommended to enclose @code{if} branches into curly braces in
each case, except it is a small simple statement. Particularly, it is
recommended to enclose @code{if} branches when it is nested to other
@code{if} or when this branch contains nested @code{if} statements.
Also, it is recommended to enclose branch in curly braces if the other
branch is enclosed.

@code{if - else if - else if@dots{}}
statements must be formatted like this:

@verbatim
    if (strcmp(reply, "yes") == 0)
    {
        ...
    }
    else if (strcmp(reply, "no") == 0)
    {
        ...
    }
    else
    {
        ...
    }
@end verbatim


@section @code{for} statement

@code{for} statement may look like this:

@verbatim
    for (i = 0; i < n; i++)
        x += buf[i];
@end verbatim

Alternative form of @code{for} statement applied when components of
@code{for} can not fit into the one 80-character line.

@verbatim
    for (p = list->head, i = 0;
         p && !(element_is_invalid(p));
         p = list_element_next(p))
    {
        list_element_register(p);
        i++;
    }
@end verbatim

It is recommended to enclose @code{for} body in curly braces in every case
except when @code{for} components fit in one line and @code{for} body is
sufficiently simple (something like @code{n += j;}, not a compound
statement).


@section @code{while} statement

@code{while} statement must look like this:
@verbatim
    while (p != NULL)
    {
        interp_evaluate_node(p);
        p = p->next;
    }
@end verbatim

It is recommended to enclose @code{while} body in curly braces in every case
except when @code{while} condition fits in one line and @code{while}
body is sufficiently simple (something like @code{n += j;}, not a compound
statement).


@section @code{do} statement

@code{do} statement must look like this:

@verbatim
    do {
        entry_process(&n, entry);
    } while (n > 0);
@end verbatim


@section @code{switch} statement

@code{switch} statement must look like this:

@verbatim
    switch (action)
    {
        case ACTION_NOP:
        case ACTION_NEXT:
            break;

        case ACTION_COPY:
            *new_type = *type;
            state = STATE_COPIED;
            break;

        case ACTION_MOVE:
            *new_type = *type;
            type = NULL;
            break;

        case ACTION_CLONE:
        {
            int i;
            
            for (i = 0; i < type_num; i++)
            {
                clone_type[i] = *type;
            }
            state = STATE_CLONED;
            break;
        }

        default:
            assert(0);
    }
@end verbatim

@code{switch} branches must be separated by empty lines. Each @code{case}
label must be placed on a separate line. You must enclose statements in
curly braces only if some local variables must be declared in block.

It is recommended to finish each @code{switch} branch with @code{break}
statement. If you really want to continue execution in the next @code{switch}
branch, insert comment @code{/* FALLTHROUGH */} before empty line which
separates two branches.

The @code{default} case, if used, should be last and does not require a
@code{break} if it is last. To make your code safer, it is recommended to add
@code{default} branch always.


@section @code{goto} statement

It is @emph{highly not recommended} to use @code{goto} statement
in your program. In most cases it means that you code has poor design.
Try to use ``structural goto'' statements, like @code{break},
@code{continue}, @code{return}. In some rare cases @code{goto} usage may be
acceptable. For example, if function performs multiple resource allocations,
and fail occurs, all allocated resources must be released. If fail condition
may occur in many places, it is possible to use @code{goto} statement to
jump to the resource deallocation fragment at the end of the function.
If it is possible to avoid such @code{goto} usage (for example, if resource
deallocation function exists and may be used) @code{goto} must not be used.


@chapter Preprocessor usage


@section Preprocessor directives formatting

Preprocessor directives must be started at column zero. It is not allowed
to have spaces between @samp{#} sign and directive name.


@section @code{#include} usage

Use @samp{<@dots{}>} with file name in @code{#include} to include
@acronym{ANSI} C headers or header files provided by the target
operating system.

Use quotes @samp{"@dots{}"} with file name to include other headers.


@section @code{#define} constant definitions

It is alternative to @code{enum} method to give symbolic names to constants.
In some cases it is more convenient than @code{enum}, but @code{enum} is a
preferred method for constant definitions (at least, because many debuggers
couldn't use preprocessing information).

@code{#define} must be used for a constant definition when the constant is
used in preprocessor expressions. Also, for example, hardware register
definitions may be included in the assembler source, so it is better to
use @code{#define} to define them.


@section Macros

It is required to around all macro parameters with parenthesis, because
complex expressions can be used as macro parameters, and operator-precedence
problems can arise. Body of function-like macros must be arounded with
parenthesis too.

Lets consider the next code fragment:

@verbatim
#define DEBUG(s) \
    if (debug)                     \
    {                              \
        printf("debug: %s\n", s);  \
    }
    
    ...
    
    if (p == NULL)
        DEBUG("p is NULL");
    else
        ...
@end verbatim

In this example, else branch of @code{if (p == NULL)} statement will become
associated with @code{if} statement in @code{DEBUG} macro. To avoid this,
all statement-like macros must be arounded by
@code{do @{ @dots{} @} while (0)} statement:

@verbatim
#define DEBUG \
    do {                               \
        if (debug)                     \
        {                              \
            printf("debug: %s\n", s);  \
        }                              \
    } while (0)
@end verbatim

Also, lets consider the following example:

@verbatim
#define INC(i) \
    do {                                                \
        printf("Loop counter new value is %d\n", ++i);  \
    } while (0)

    ...

    for (i = 0; i < 5; ({INC(i);}))
    {
        ...
    }
@end verbatim

The example states how macros arounded by @code{do @{ @dots{} @} while (0)}
statement may be used in @code{for()} statement components. The macro call
is arounded by curly and, then, round brackets.

It is recommended to hold macros on one line if it is possible. If no,
format macros as it is shown in a bad example above. Line up all
continuation backslashes on right side of macro body. Check that backslash
is a last character in this string. Do not put any code in first line where
macros name and parameters given. Follow to the indentation rules in body of
macros.

Function-like macros must be commented like functions. Types of parameters
should be stated in macro description.

It's recommented to use inline functions instead of function-like macros,
if it is applicable. Compiler can help to avoid some errors and its output
in the case of compilation errors more friendly, if inline function is used.


@section Conditional compilation

Conditional compilation is useful for making your code portable by handling
different machines and OS behavior. Also, it is useful for debugging and
for setting certain options at compile time. Be careful: various controls
may easily combine in unforeseen ways. Check for error condition combination
or absence or incorrect value of some preprocessor variables. In last case,
use preprocessor directive @code{#error} to handle such situations.

It is recommended to maintain syntactic correctness in false branches.

Try to put @code{#if}/@code{#ifdef} directives in header files instead C
source file. Use @code{#if}/@code{#ifdef} to define macros that can be used
uniformly in the code. For instance, a header file for checking memory
allocation might look like:

@verbatim
#ifdef DEBUG
    extern void *mm_malloc(size_t bytes);
#define MALLOC(size) (mm_malloc(size))
#else
    extern void *malloc(size_t bytes);
#define MALLOC(size) (malloc(size))
#endif
@end verbatim

It is recommended to use indentation rules for preprocessor conditions too.

Conditional compilation should generally be on a feature-by-feature basis.
Although, one of usage of conditional preprocessor directives is to handle
differences between different machines or operating systems. OS type,
CPU kind, board, implementation etc. dependencies via conditional
compilation should be avoided in most cases. Use name of the feature or
property instead of name of bearing entiry.

You may exclude fragment of your code using @code{#if 0} directive.


@chapter Warning messages


Your program must be compiled without any warning messages for all target 
architectures. All warning messages must be enabled in compiler
(@code{'-Wall -W'} flags enable all warnings in GCC).

Of course, error messages not acceptable too.

These conditions are applied to any code surrounded by conditional preprocessor
statements, including traces, checks, debugging prints, assertions etc.
The only exception is a temporary code fragment between @code{#if 0/#endif}
statements. Such fragments must be removed before code freezing or
releasing.


@chapter Project-Dependent Standards


Individual projects may wish to establish additional standards beyond those
given here. It is good and recommended practice to define on a per-project
basis additional naming conventions, including common prefix conventions,
rules for function or data structures grouping, restrictions to libraries
and headers which may be used in project, preprocessor variables and
macros usage, include files organization etc.

It is highly recommended to make those standards compliant to this one.

@contents

@bye
